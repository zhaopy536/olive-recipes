"""
Model parameter configuration classes
"""

from __future__ import annotations

import json
import os
import re
from pathlib import Path
from typing import Any, Dict, Iterator, List, Optional

from deepdiff import DeepDiff
from model_lab import RuntimeEnum
from pydantic import BaseModel

from .base import BaseModelClass
from .constants import (
    EPNames,
    OliveDeviceTypes,
    OlivePassNames,
    OlivePropertyNames,
    ParameterActionTypeEnum,
    ParameterTagEnum,
    ParameterTypeEnum,
    PhaseTypeEnum,
)
from .model_info import ModelInfo, ModelList
from .parameters import Parameter, ParameterAction
from .utils import (
    GlobalVars,
    checkPath,
    get_eval_in_execute_runtime,
    get_eval_runtime,
    get_execute_runtime,
    get_target_system,
    isLLM_by_id,
    open_ex,
    printError,
    printProcess,
    printWarning,
)


class RuntimeOverwrite(BaseModel):
    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it
    autoGenerated: Optional[bool] = None
    pyEnvPath: Optional[str] = None
    executeEp: Optional[EPNames] = None
    executeOliveDeviceType: Optional[OliveDeviceTypes] = None
    executeRequirement: Optional[str] = None
    # This is usually used for EP binary generation
    evaluateUsedInExecute: Optional[bool] = None

    def Check(self, oliveJson: Any):
        if self.executeEp and self.executeRequirement:
            printError(f"executeEp and executeRequirement should not both be set")
            return False
        if self.executeRequirement:
            pattern = r"^[^/\\]+/[^/\\]+_py\d\.\d+\.\d+$"
            if not re.match(pattern, self.executeRequirement):
                printError(f"executeRequirement should be like XXX/YYY_py3.13.6")
                return False
        if self.pyEnvPath:
            if not checkPath(self.pyEnvPath, oliveJson):
                return False
        return True


class Section(BaseModel):
    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it
    autoGenerated: Optional[bool] = None
    name: str
    phase: PhaseTypeEnum
    description: Optional[str] = None
    parameters: List[Parameter]
    disableToggleGeneration: Optional[bool] = None
    toggle: Optional[Parameter] = None

    @staticmethod
    def datasetPathPattern(path: str):
        return re.fullmatch(r"data_configs\[(0|[1-9]\d{0,2})\]\.load_dataset_config\.data_name", path)

    def Check(
        self,
        templates: Dict[str, Parameter],
        _file: str,
        sectionId: int,
        oliveJson: Any,
        modelList: ModelList,
    ):
        if not self.name:
            return False
        # if not self.description:
        #    return False
        # TODO add place holder for General?
        if not self.parameters and self.phase != PhaseTypeEnum.Conversion:
            printWarning(f"{_file} self.parameters is empty for {self.phase}.")

        for i, parameter in enumerate(self.parameters):
            if parameter.template:
                template = parameter.template
                if not isinstance(template, Parameter):
                    printError(f"{_file} section {sectionId} parameter {i} has wrong template")
                    continue
                if template.template not in templates:
                    printError(f"{_file} section {sectionId} parameter {i} has wrong template")
                    continue
                parameter.clearValue()
                parameter.applyTemplate(template)
                parameter.applyTemplate(templates[str(template.template)])
            if not parameter.Check(False, oliveJson, modelList):
                printError(f"{_file} section {sectionId} parameter {i} has error")

            # TODO move tag check into Parameter
            if parameter.path and Section.datasetPathPattern(parameter.path):
                if self.phase == PhaseTypeEnum.Quantization:
                    if not parameter.tags or ParameterTagEnum.QuantizationDataset not in parameter.tags:
                        printError(f"{_file} section {sectionId} parameter {i} should have QuantizationDataset tag")
                elif self.phase == PhaseTypeEnum.Evaluation:
                    if not parameter.tags or ParameterTagEnum.EvaluationDataset not in parameter.tags:
                        printError(f"{_file} section {sectionId} parameter {i} should have EvaluationDataset tag")
                if parameter.values:
                    missing_keys = [key for key in parameter.values if key not in modelList.HFDatasets]
                    if missing_keys:
                        printError(f"datasets are not in HFDatasets: {', '.join(str(key) for key in missing_keys)}")
            elif parameter.path and parameter.path.endswith("activation_type"):
                if not parameter.tags or ParameterTagEnum.ActivationType not in parameter.tags:
                    printError(f"{_file} section {sectionId} parameter {i} should have ActivationType tag")
            elif parameter.path and parameter.path.endswith("weight_type"):
                if not parameter.tags or ParameterTagEnum.WeightType not in parameter.tags:
                    printError(f"{_file} section {sectionId} parameter {i} should have WeightType tag")

        if self.toggle:
            if self.toggle.type != ParameterTypeEnum.Bool:
                printError(f"{_file} section {sectionId} toggle must use bool")
                return False
            if not self.toggle.Check(False, oliveJson, modelList):
                printError(f"{_file} section {sectionId} toggle has error")

        return True


class ADMNPUConfig(BaseModel):
    inferenceSettings: Optional[Any] = None


class DebugInfo(BaseModel):
    autoGenerated: bool = True
    # This kind of config will
    # - could not disable quantization
    # - use modelbuilder for conversion
    # - output a model folder instead of model file
    useModelBuilder: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use OpenVINOConversion for conversion
    useOpenVINOConversion: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use OpenVINOConversion for conversion
    useOpenVINOOptimumConversion: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use QuarkQuantization for conversion
    useQuarkQuantization: Optional[str] = None

    def setupUseX(self, oliveJson: Any):
        def getPass(passType: str):
            return next(
                (
                    k
                    for k, v in oliveJson[OlivePropertyNames.Passes].items()
                    if v[OlivePropertyNames.Type].lower() == passType
                ),
                None,
            )

        self.useModelBuilder = getPass(OlivePassNames.ModelBuilder)
        self.useOpenVINOConversion = getPass(OlivePassNames.OpenVINOConversion)
        self.useOpenVINOOptimumConversion = getPass(OlivePassNames.OpenVINOOptimumConversion)
        self.useQuarkQuantization = getPass(OlivePassNames.QuarkQuantization)

        notEmpty = [
            v
            for v in [
                self.useModelBuilder,
                self.useOpenVINOConversion,
                self.useOpenVINOOptimumConversion,
                self.useQuarkQuantization,
            ]
            if v
        ]
        self._use = notEmpty[0] if notEmpty else None
        if len(notEmpty) > 1:
            printError(f"should not mix them")
            return False
        return True

    def getUseX(self):
        return self._use

    def isEmpty(self):
        return not self._use


class ModelParameter(BaseModelClass):
    name: str
    oliveFile: Optional[str] = None
    # SET AUTOMATICALLY TO TRUE BY MODEL ID
    isLLM: Optional[bool] = None
    isIntel: Optional[bool] = None
    intelRuntimeValues: Optional[List[OliveDeviceTypes]] = None
    # For template using CUDA and no runtime overwrite, we need to set this so we know the target EP
    evalRuntime: Optional[RuntimeEnum] = None
    debugInfo: Optional[DebugInfo] = None
    # A SHORTCUT FOR SEVERAL PARAMETERS
    # This kind of config will
    # - setup runtimeOverwrite for CUDA EP and others
    #   + the previous EP is used for EPContextBinaryGeneator by PythonEnvironment
    # - do not support cpu evaluation
    # - setup executeRuntimeFeatures, pyEnvRuntimeFeatures
    isQNNLLM: Optional[bool] = None
    # SET AUTOMATICALLY TO TRUE WHEN CUDAExecutionProvider
    isGPURequired: Optional[bool] = None
    runtimeOverwrite: Optional[RuntimeOverwrite] = None
    executeRuntimeFeatures: Optional[List[str]] = None
    evaluationRuntimeFeatures: Optional[List[str]] = None
    pyEnvRuntimeFeatures: Optional[List[str]] = None
    # it means default template does not use it
    # for Cpu, None means add
    addCpu: Optional[bool] = None
    addAmdNpu: Optional[ADMNPUConfig] = None

    runtime: Optional[Parameter] = None
    runtimeInConversion: Optional[Parameter] = None
    sections: List[Section] = []

    @staticmethod
    def Read(parameterFile: str):
        printProcess(parameterFile)
        with open_ex(parameterFile, "r") as file:
            parameterContent = file.read()
        modelParameter = ModelParameter.model_validate_json(parameterContent, strict=True)
        modelParameter._file = parameterFile
        modelParameter._fileContent = parameterContent
        return modelParameter

    def getIntelDevices(self) -> Iterator[OliveDeviceTypes]:
        for tmpDevice in OliveDeviceTypes:
            if tmpDevice == OliveDeviceTypes.Any:
                continue
            if self.intelRuntimeValues and tmpDevice not in self.intelRuntimeValues:
                continue
            yield tmpDevice

    def Check(self, templates: Dict[str, Parameter], oliveJson: Any, modelList: ModelList, modelInfo: ModelInfo):
        GlobalVars.configCheck.append(self._file)

        if not self.checkDebugInfo(oliveJson):
            return

        self.isLLM = isLLM_by_id(modelInfo.id) or None

        if self.sections and self.sections[0].phase == PhaseTypeEnum.Conversion:
            self.sections = self.sections[1:]
        self.sections.insert(
            0,
            Section(
                autoGenerated=True,
                name="Convert",
                phase=PhaseTypeEnum.Conversion,
                parameters=[],
            ),
        )

        if self.isQNNLLM:
            self.addCpu = False

        # Add runtime
        syskey, system = get_target_system(oliveJson)
        currentEp = system[OlivePropertyNames.Accelerators][0][OlivePropertyNames.ExecutionProviders][0]
        currentOliveDeviceType = system[OlivePropertyNames.Accelerators][0].get(
            OlivePropertyNames.Device, OliveDeviceTypes.Any.value
        )
        currentRuntimeRPC = GlobalVars.GetRuntimeRPC(currentEp, currentOliveDeviceType)
        # use any for default
        if currentEp == EPNames.OpenVINOExecutionProvider.value:
            currentRuntimeRPC = RuntimeEnum.IntelAny

        runtimeValues: List[str] = [currentEp]
        runtimeDisplayNames = [GlobalVars.RuntimeToDisplayName[currentRuntimeRPC]]

        runtimeActions = None

        # CPU always last
        if self.addCpu != False and currentRuntimeRPC != RuntimeEnum.CPU:
            runtimeValues.append(GlobalVars.RuntimeToEPName[RuntimeEnum.CPU].value)
            runtimeDisplayNames.append(GlobalVars.RuntimeToDisplayName[RuntimeEnum.CPU])
            if runtimeActions is not None:
                runtimeActions.append([])

        self.runtime = Parameter(
            autoGenerated=True,
            name="Evaluate on",
            type=ParameterTypeEnum.Enum,
            values=runtimeValues,
            displayNames=runtimeDisplayNames,
            path=f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.Accelerators}.0.{OlivePropertyNames.ExecutionProviders}.0",
            readOnly=False,
        )
        if currentEp == EPNames.OpenVINOExecutionProvider.value:
            self.runtime.path = (
                f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.Accelerators}.0.{OlivePropertyNames.Device}"
            )
            self.runtime.values = []
            self.runtime.displayNames = []
            for tmpDevice in self.getIntelDevices():
                tmpRuntimeRPC = GlobalVars.GetRuntimeRPC(EPNames.OpenVINOExecutionProvider, tmpDevice)
                self.runtime.values.append(GlobalVars.RuntimeToOliveDeviceType[tmpRuntimeRPC].value)
                self.runtime.displayNames.append(GlobalVars.RuntimeToDisplayName[tmpRuntimeRPC])

        self.runtime.actions = runtimeActions
        self.TryToRemoveReuseCacheInRuntimeAction(oliveJson, modelInfo)
        if not self.runtime.Check(False, oliveJson, modelList):
            printError(f"{self._file} runtime has error")

        # Add runtime overwrite
        if self.isQNNLLM:
            if not system[OlivePropertyNames.Type] == "PythonEnvironment":
                printError(f"{self._file}'s olive json does not use PythonEnvironment")
            self.runtimeOverwrite = RuntimeOverwrite(
                autoGenerated=True,
                pyEnvPath=f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.PythonEnvironmentPath}",
                executeEp=EPNames.CUDAExecutionProvider,
                evaluateUsedInExecute=True,
            )
            self.executeRuntimeFeatures = ["AutoGptq"]
            self.pyEnvRuntimeFeatures = ["Nightly"]

        if self.runtimeOverwrite and not self.runtimeOverwrite.Check(oliveJson):
            printError(f"{self._file} runtime overwrite has error")

        for tmpDevice, section in enumerate(self.sections):
            # Add conversion toggle
            if section.phase == PhaseTypeEnum.Conversion:
                if not section.disableToggleGeneration:
                    conversion = None
                    if self.debugInfo:
                        conversion = self.debugInfo.getUseX()
                    if not conversion:
                        conversion = [
                            k
                            for k, v in oliveJson[OlivePropertyNames.Passes].items()
                            if v[OlivePropertyNames.Type].lower() == OlivePassNames.OnnxConversion
                        ][0]
                    conversionPath = f"{OlivePropertyNames.Passes}.{conversion}"
                    section.toggle = Parameter(
                        autoGenerated=True,
                        name="Convert to ONNX format",
                        type=ParameterTypeEnum.Bool,
                        path=conversionPath,
                        actions=[[], []],
                        readOnly=True,
                    )

            # Add quantization toggle
            elif section.phase == PhaseTypeEnum.Quantization:
                if not section.disableToggleGeneration:
                    toggleReadOnly = None
                    actions = []
                    quantize = None
                    if self.debugInfo:
                        quantize = self.debugInfo.getUseX()
                    if quantize:
                        toggleReadOnly = True
                    else:
                        quantize = [
                            k
                            for k, v in oliveJson[OlivePropertyNames.Passes].items()
                            if v[OlivePropertyNames.Type].lower()
                            in [
                                OlivePassNames.OnnxQuantization,
                                OlivePassNames.OnnxStaticQuantization,
                                OlivePassNames.OnnxDynamicQuantization,
                                # for trtrtx
                                OlivePassNames.OnnxFloatToFloat16,
                            ]
                        ][0]
                        conversion = [
                            (k, v)
                            for k, v in oliveJson[OlivePropertyNames.Passes].items()
                            if v[OlivePropertyNames.Type].lower() == OlivePassNames.OnnxConversion
                        ][0]
                        actions = [
                            ParameterAction(
                                path=f"{OlivePropertyNames.Passes}",
                                type=ParameterActionTypeEnum.Update,
                                value={conversion[0]: conversion[1]},
                            )
                        ]
                    quantizePath = f"{OlivePropertyNames.Passes}.{quantize}"
                    section.toggle = Parameter(
                        autoGenerated=True,
                        name="Quantize model",
                        type=ParameterTypeEnum.Bool,
                        path=quantizePath,
                        readOnly=toggleReadOnly,
                        actions=[[], actions],
                    )

            # Add evaluation toggle
            elif section.phase == PhaseTypeEnum.Evaluation:
                if not section.disableToggleGeneration:
                    action = ParameterAction(
                        path=OlivePropertyNames.Evaluator,
                        type=ParameterActionTypeEnum.Delete,
                    )
                    section.toggle = Parameter(
                        autoGenerated=True,
                        name="Evaluate model performance",
                        type=ParameterTypeEnum.Bool,
                        path=OlivePropertyNames.Evaluator,
                        actions=[[], [action]],
                    )
                evaluatorName = oliveJson[OlivePropertyNames.Evaluator]
                if not checkPath(f"{OlivePropertyNames.Evaluators}.{evaluatorName}", oliveJson):
                    printError(f"{self._file} does not have evaluator {evaluatorName}")

            if not section.Check(templates, self._file or "", tmpDevice, oliveJson, modelList):
                printError(f"{self._file} section {tmpDevice} has error")

        if (
            currentEp == EPNames.CUDAExecutionProvider.value
            or self.runtimeOverwrite
            and self.runtimeOverwrite.executeEp == EPNames.CUDAExecutionProvider
        ):
            self.isGPURequired = True
        else:
            self.isGPURequired = None

        self.checkPhase(oliveJson)
        self.CheckRuntimeInConversion(oliveJson, modelList, modelInfo)
        self.checkOliveFile(oliveJson, modelInfo)
        self.checkRequirements(modelList)
        if self.debugInfo and self.debugInfo.isEmpty():
            self.debugInfo = None
        self.writeIfChanged()

    def TryToRemoveReuseCacheInRuntimeAction(self, oliveJson: Any, modelInfo: ModelInfo):
        if not self.runtime or not self.runtime.values:
            printError(f"{self._file} runtime values is empty, cannot remove reuse_cache")
            return
        # Find all passes that have reuse_cache field
        reuse_cache_paths = []
        if OlivePropertyNames.Passes in oliveJson:
            for pass_key, pass_value in oliveJson[OlivePropertyNames.Passes].items():
                if "reuse_cache" in pass_value:
                    reuse_cache_path = f"{OlivePropertyNames.Passes}.{pass_key}.reuse_cache"
                    reuse_cache_paths.append(reuse_cache_path)

        if reuse_cache_paths:
            # Previously, in debug mode for olive, this will throw exception 'file is occupied' for ov recipes
            # Seem fixed here https://github.com/microsoft/Olive/pull/2017/files
            return None
            if self.runtime.actions is None:
                self.runtime.actions = []
            for i in range(len(self.runtime.values)):
                if i >= len(self.runtime.actions):
                    self.runtime.actions.append([])
                for tmpPath in reuse_cache_paths:
                    self.runtime.actions[i].append(
                        ParameterAction(
                            path=tmpPath,
                            type=ParameterActionTypeEnum.Delete,
                        )
                    )
        return None

    def CheckRuntimeInConversion(self, oliveJson: Any, modelList: ModelList, modelInfo: ModelInfo):
        self.runtimeInConversion = None
        return

        def getOpenVINOPass(passType: str):
            return next(
                (
                    (k, v)
                    for k, v in oliveJson[OlivePropertyNames.Passes].items()
                    if v[OlivePropertyNames.Type].lower() == passType
                ),
                None,
            )

        openVINOOptimumConversion = getOpenVINOPass(OlivePassNames.OpenVINOOptimumConversion)
        openVINOQuantization = getOpenVINOPass(OlivePassNames.OpenVINOQuantization)
        openVINOEncapsulation = getOpenVINOPass(OlivePassNames.OpenVINOEncapsulation)

        def addRuntimeInConversion(runtime: Parameter, path: str, values: List[Any]):
            if not runtime.path:
                runtime.path = path
                runtime.values = values
                runtime.displayNames = [
                    GlobalVars.RuntimeToDisplayName[GlobalVars.GetRuntimeRPC(EPNames.OpenVINOExecutionProvider, e)]
                    for e in values
                ]
            else:
                if runtime.actions is None:
                    runtime.actions = []
                for i in range(len(values)):
                    if i >= len(runtime.actions):
                        runtime.actions.append([])
                    runtime.actions[i].append(
                        ParameterAction(
                            path=path,
                            type=ParameterActionTypeEnum.Update,
                            value=values[i],
                        )
                    )

        if openVINOOptimumConversion or openVINOQuantization or openVINOEncapsulation:
            self.runtimeInConversion = Parameter(
                autoGenerated=True, name="Convert/Quantize to", type=ParameterTypeEnum.Enum
            )
            if openVINOOptimumConversion:
                addRuntimeInConversion(
                    self.runtimeInConversion,
                    f"{OlivePropertyNames.Passes}.{openVINOOptimumConversion[0]}.{OlivePropertyNames.ExtraArgs}.{OlivePropertyNames.Device}",
                    # TODO support any after olive release
                    [e.value for e in self.getIntelDevices()],
                )
            if openVINOQuantization:
                addRuntimeInConversion(
                    self.runtimeInConversion,
                    f"{OlivePropertyNames.Passes}.{openVINOQuantization[0]}.{OlivePropertyNames.TargetDevice}",
                    # TODO support any after olive release
                    [e.value for e in self.getIntelDevices()],
                )
            if openVINOEncapsulation:
                addRuntimeInConversion(
                    self.runtimeInConversion,
                    f"{OlivePropertyNames.Passes}.{openVINOEncapsulation[0]}.{OlivePropertyNames.TargetDevice}",
                    # TODO support any after olive release
                    [e.value for e in self.getIntelDevices()],
                )
            if not self.runtimeInConversion.Check(False, oliveJson, modelList):
                printError(f"{self._file} runtime in conversion has error")

    def checkPhase(self, oliveJson: Any):
        allPhases = [section.phase for section in self.sections]
        if len(allPhases) == 1 and allPhases[0] == PhaseTypeEnum.Conversion:
            pass
        elif (
            len(allPhases) == 2
            and allPhases[0] == PhaseTypeEnum.Conversion
            and allPhases[1] in [PhaseTypeEnum.Quantization, PhaseTypeEnum.Evaluation]
        ):
            pass
        elif (
            len(allPhases) == 3
            and allPhases[0] == PhaseTypeEnum.Conversion
            and allPhases[1] == PhaseTypeEnum.Quantization
            and allPhases[2] == PhaseTypeEnum.Evaluation
        ):
            pass
        else:
            printError(f"{self._file} has wrong phases {allPhases}")

        if (
            PhaseTypeEnum.Evaluation in allPhases
            and PhaseTypeEnum.Quantization in allPhases
            and len(oliveJson[OlivePropertyNames.DataConfigs]) != 2
        ):
            printWarning(f"{self._file}'s olive json should have two data configs for evaluation")

    def checkOliveFile(self, oliveJson: Any, modelInfo: ModelInfo):
        if not GlobalVars.olivePath:
            return
        if modelInfo.extension:
            return
        if not self.oliveFile:
            if self.runtime and self.runtime.displayNames and self.runtime.displayNames[0] == GlobalVars.RuntimeToDisplayName[RuntimeEnum.DML]:
                return
            printWarning(f"{self._file} does not have oliveFile")
            return

        with open_ex(os.path.join(GlobalVars.olivePath, "examples", self.oliveFile), "r") as file:
            oliveFileJson = json.load(file)

        diff = DeepDiff(
            oliveFileJson[OlivePropertyNames.Passes],
            oliveJson[OlivePropertyNames.Passes],
        )

        addeds: list[str] = diff.pop("dictionary_item_added", [])
        newAddeds = []
        for added in addeds:
            if added.endswith("['save_as_external_data']"):
                # We add it to align model format
                pass
            else:
                newAddeds.append(added)
        if newAddeds:
            diff["dictionary_item_added"] = newAddeds

        removeds: list[str] = diff.pop("dictionary_item_removed", [])
        newRemoveds = []
        for removed in removeds:
            if removed == "root['add_metadata']":
                pass
            else:
                newRemoveds.append(removed)
        if newRemoveds:
            diff["dictionary_item_removed"] = newRemoveds

        changeds: dict[str, Any] = diff.pop("values_changed", {})
        newChangeds = {}
        for changed in changeds:
            if changed.endswith("['data_config']") or changed.endswith("['user_script']"):
                # Data config name or *.py could be different
                pass
            else:
                newChangeds[changed] = changeds[changed]
        if newChangeds:
            diff["values_changed"] = newChangeds

        if diff:
            path = Path(self._file if self._file else "UNKNOWN")
            printError(f"{"/".join(path.parts[-3:])} different from {self.oliveFile}\r\n{diff}")
        GlobalVars.oliveCheck += 1

    def checkDebugInfo(self, oliveJson: Any):
        self.debugInfo = DebugInfo()
        if not self.debugInfo.setupUseX(oliveJson):
            return False
        return True

    def checkRequirements(self, modelList: ModelList):
        if not self.runtime or not self.runtime.displayNames:
            printError(f"{self._file} runtime is not set")
            return

        req_path = Path(__file__).parent.parent.parent / "requirements"
        # TODO only check 1st one
        execute_runtime = modelList.DisplayNameToRuntimeRPC[self.runtime.displayNames[0]]
        if self.runtimeOverwrite and self.runtimeOverwrite.executeEp:
            execute_runtime = GlobalVars.GetRuntimeRPC(self.runtimeOverwrite.executeEp, OliveDeviceTypes.Any)
        if self.runtimeOverwrite and self.runtimeOverwrite.executeRequirement:
            execute_runtime_value = self.runtimeOverwrite.executeRequirement
        else:
            execute_runtime_value = get_execute_runtime(execute_runtime).value
        self.checkRequirement(req_path, execute_runtime_value)
        if self.executeRuntimeFeatures:
            for feature in self.executeRuntimeFeatures:
                self.checkRequirement(req_path, f"{execute_runtime_value}-{feature}")

        eval_runtime = modelList.DisplayNameToRuntimeRPC[self.runtime.displayNames[0]]
        if self.evalRuntime:
            eval_runtime = self.evalRuntime

        if self.runtimeOverwrite and self.runtimeOverwrite.evaluateUsedInExecute:
            eval_in_execute_runtime = get_eval_in_execute_runtime(eval_runtime)
            self.checkRequirement(req_path, eval_in_execute_runtime.value)
            if self.pyEnvRuntimeFeatures:
                for feature in self.pyEnvRuntimeFeatures:
                    self.checkRequirement(req_path, f"{eval_in_execute_runtime.value}-{feature}")

        eval_runtime = get_eval_runtime(eval_runtime, self.isLLM or False)
        self.checkRequirement(req_path, eval_runtime.value)
        if self.evaluationRuntimeFeatures:
            for feature in self.evaluationRuntimeFeatures:
                self.checkRequirement(req_path, f"{eval_runtime.value}-{feature}")

    def checkRequirement(self, path: Path, name: str):
        file = path / f"{name}.txt" if "_py" in name else path / f"requirements-{name}.txt"
        if not file.exists():
            printError(f"Missing requirement file: {file} for {self._file}")
        else:
            GlobalVars.venvRequirementsCheck.add(str(file))
